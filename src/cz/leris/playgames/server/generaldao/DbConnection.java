package cz.leris.playgames.server.generaldao;

import cz.leris.playgames.server.generaldao.exceptions.DaoException;
import cz.leris.playgames.server.generaldao.exceptions.DaoExceptionType;
import cz.leris.playgames.server.generaldao.exceptions.SetException;
import cz.leris.playgames.server.generaldao.exceptions.GetException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

/**
 * Created by jirka on 23.6.17.
 */
public final class DbConnection implements StatementFactory, AutoCloseable {
	private final Logger logger = LoggerFactory.getLogger(DbConnection.class);

    private final Connection con;
	private Transactional transactional;

	private interface Transactional {
		<T> T execute(TransactionTask<T> t) throws Exception;
	}

	private class FirstLevelTransactional implements Transactional {
		@Override
		public <T> T execute(TransactionTask<T> t) throws Exception {
			transactional = new NestedTransactional();
			startTransaction();
			logger.info("<DbConnection> Starting main transaction");
			try {
				T result = t.execute(DbConnection.this);
				commit();
				logger.info("<DbConnection> Main transaction commited");
				return result;
			} catch (Exception e) {
				rollback();
				logger.error("<DbConnection> Main transaction rollback", e);
				throw e;
			} finally {
				transactional = this;
			}
		}
	}

	private class NestedTransactional implements Transactional {
		@Override
		public <T> T execute(TransactionTask<T> t) throws Exception {
			logger.info("<DbConnection> Starting nested transaction");
			T result = t.execute(DbConnection.this);
			logger.info("<DbConnection> Ending nested transaction");
			return result;
		}
	}

    public DbConnection(final Connection con) {
        this.con = con;
		this.transactional = new FirstLevelTransactional();
    }

    private void startTransaction() throws SQLException {
        con.setAutoCommit(false);
    }

    private void commit() throws SQLException {
        con.commit();
		finishTransaction();
    }

    private void finishTransaction() throws SQLException {
        con.setAutoCommit(true);
    }

    private void rollback() throws SQLException {
        con.rollback();
		finishTransaction();
    }

    @Override
    public PreparedStatement prepareStatement(final String sql) throws SQLException {
		return con.prepareStatement(sql);
    }

    @Override
    public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
        return con.prepareStatement(sql, autoGeneratedKeys);
    }

	@Override
	public <T> T execute(TransactionTask<T> t) throws DaoException {
		try {
			return transactional.execute(t);
		} catch(DaoException e) {
			throw e;
		} catch(Exception e) {
			throw new DaoException(null, DaoExceptionType.INVALID_ACTION, "Transaction failed");
		}
	}

	@Override
	public void close() throws Exception {
		if(con != null && !con.isClosed()) {
			con.close();
		}
	}

	public <T> T execute(SetDao<T> setDao) throws SetException {
		return setDao.execute(this);
	}

	public <T> T execute(GetDao<T> getDao) throws GetException {
		return getDao.execute(this);
	}
}
